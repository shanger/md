# 缓存
缓存是为了提升客户端和服务端的交互效率，提升性能节省开支的重要方式。
## 缓存控制
缓存控制分为两部分，强制缓存和协商缓存。
* 强制缓存，浏览器会判断本地缓存是否过期，未过期的可直接使用，无需向服务端发送请求。

* 协商缓存，浏览器向服务端发送请求，会带上请求文件的状态供服务端判断是否过期，如果未过期则可以使用本地缓存，否则从服务端返回。

以上两种缓存方式通过HTTP的头部信息来控制。

### 强制缓存
HTTP1.0使用`Expires`来控制，用来控制在规定时间内，浏览器不会发送请求直接使用本地缓存，Expires对应服务端时间，但这样会带来一个问题，如果客户端时间和服务端时间不一致就有可能导致本地缓存无效，或者一直无法过期的问题。于是HTTP1.1出现了一个新的
头部`Cache-Control`,这里我们先提到他的一个取值`Max-Age`，该值是绝对时间（**设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)**），就不存在以上问题。

**如果同时启用了Cache-Control与Expires，Cache-Control优先级高。**

ps:这里简单介绍下`Cache-Control`的其他常用取值
取值|信息
--:|--
public|表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容（例如，该响应没有max-age指令或Expires消息头）。
private|表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容
no-cache|在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证。
no-store|缓存不应存储有关客户端请求或服务器响应的任何内容。
max-age|设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。

### 协商缓存
HTTP1.0中由一对头部属性实现`If-Modified-Since/Last-Modified`，这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是`If-Modified-Since`，而服务端的是`Last-Modified`，它的作用是，在发起请求时，如果`If-Modified-Since`和`Last-Modified`匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。`Last-Modified`，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内。这套实现的缺陷就是，文件的修改只能精确到秒，而且只要文件有任何信息修改都会更新`Last-Modified`比如只修改了修改时间，HTTP1.0中的ETag解决了以上问题，服务端通过某种算法给文件生成一个指纹标记，但是生成ETag的过程是需要计算资源的，会带来一定的性能消耗。

**如果请求同时带有E-tag和Last-Modified，服务端会优先检查E-tag**

## 强制缓存和协商缓存的优先级

Etag 和 Expire 一起使用时，先判断 Expire ，如果已经过期，再发起 Http 请求，如果 Etag 也过期，则返回 200 响应。如果 Etag 没有过期则返回 304 响应。

Last-Modified,Etag,Expires 三个同时使用时。先判断 Expire ，然后发送 Http 请求，服务器先判断 Etag再 last-modified ，必须都没有过期，才能返回 304 响应。（待验证）